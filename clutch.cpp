/*
 *  The first attempt at a program to find transversal counterexamples in rectangles
 *
 *  Procedure:
 *
 *  1)  Generate the canonical forms using util/gen_canon.cpp (instructions included in file.)
 *  2)  Create an input file as described below.
 *  3)  Compile the file (eg: clang++ clutch.cpp -O3 -oclutch)
 *  4)  Run (eg: ./clutch < input.txt)
 *
 *
 *  Input File Format:
 *
 *      N.B:    This format was created from combining previous utilities and experiments and
 *              will most likely be replaced with something better eventually.
 *
 *              Frequencies cannot exceed a single digit. (Shouldn't be a problem for the sizes
 *              we are expecting.)
 *
 *              Only attemps one configuration of frequencies, allowing for multiple instances
 *              to be run using different frequency setups as the program is not multithreaded
 *              whatsoever.
 *
 *      n m fmax                        (Number of rows, columns, and maximum frequency)
 *      f1f2f3f4...fn                   (list of frequencies starting with fmax)
 *      canon_list_fmax.file            (Path to canonical form files generated by util/gen_canon)
 *      canon_list_fmax-1.file
 *      ...
 *      canon_list_1.file
 *
 *  TODO:
 *          - Don't insert cforms we know won't work
 */

#ifdef DEBIAN
#include <boost/timer/timer.hpp>
#endif

#include <boost/unordered_set.hpp>
#include <iostream>
#include <fstream>
#include <vector>
#include <queue>
#include "qnode.h"
#include "cform.h"

using namespace std;

int main(int argc, char **argv)
{
#ifdef DEBIAN
	cout << "!Timer Started." << endl;
	boost::timer::auto_cpu_timer t_dot;
#endif

    bool verbose = true;
    bool dreadly = true;
    int m, n, f, lim;
    qnode single;
    vector<int> cstart;
    string fline, freqs, initial;
    vector< vector<cform> > forms;

    priority_queue< qnode, vector<qnode>, less<vector<qnode>::value_type> > nqueue;
    boost::unordered_set< qnode, boost::hash<qnode> > nhash;
    pair< boost::unordered_set<qnode>::iterator, bool> ihash;
    
    //---- Reading data from input files
    
    cin >> m >> n >> f >> lim;
    forms.resize(f);
    if(verbose)
    {
        cout << "!m n f: " << m << " " << n << " " << f;
        if(lim >= 0) cout << " lim == " << lim;
        cout << endl;
    }

    getline(cin, freqs);
    getline(cin, freqs);
    if(verbose) cout << "!Freqs: " << freqs << endl;
    initial = get_initial(m,n);
    
    int curr = f;
    //-------- Reading canonical forms
    if(getline(cin, fline))
    {
        if(verbose) cout << "!Opening File: " << fline << endl;
        ifstream fhandle;
        string sline;

        fhandle.open(fline.c_str(), ifstream::in);
        if(fhandle.is_open())
        {
            int lc=1;
            int count=0;
            while(getline(fhandle, sline))
            {
                if(lc%(m*n+4) == 0)
                {
                    if(lim < 0 || lim == count)
                    {
                        single = qnode(sline, count, m, n);
                        nqueue.push(single);
                        ihash = nhash.insert(single);
                        if(verbose && lim >= 0)
                        {
                            cout << "!Initial Insert:\n";
                            single.print_clean_comment();
                        }
                    }
                    count++;
                }
                lc++;
            }
        }
		else
		{
			fprintf(stderr, "Error: Unable to open file %s\n", fline.c_str());
		}
    }

    //-------- Read canonical permutations
    int debug_count = 0;
    int debug_insert = 0;

    while(getline(cin, fline) && curr >= 0)
    {
        if(verbose) cout << "!Opening File: " << fline << endl;
        ifstream fhandle;
        string sline;
        vector<cform> vec;

        fhandle.open(fline.c_str(), ifstream::in);
        if(fhandle.is_open())
        {
            while(getline(fhandle, sline))
            {
                //Then this is the newer version of input files that distinguish
                //which canonical form they came from.
                if(sline.length() < m*n)
                {
                    cstart.push_back(debug_count);
                }
                else
                {
                    debug_count++;
                    cform ttemp = cform(sline, m, n);
                    //ttemp.print_clean(m,n);

                    if( lim < 0 || (lim >= 0 && !single.overlap_check(ttemp)) )
                    {
                        debug_insert++;
                        vec.push_back(ttemp);
                    }
                }
            }
            sort(vec.begin(), vec.end());
            if(verbose) cout << "!Insert Forms " << curr << " " << vec.size() << endl;
            forms[--curr] = vec;
        }
        else
        {
			fprintf(stderr, "Error: Unable to open file %s\n", fline.c_str());
            //cout << "Could not open file: " << fline << endl;
            //return 1;
        }
    }

    if(verbose) cout << "!DEBUG INSERTS: " << debug_insert << "/" << debug_count << endl;
    if(verbose) cout << "!Queue Size: " << nqueue.size() << endl;
    int counter_count = 0;
    int valid_count = 0;
    int insert_count = 0;
    int last_counter = 0;
    int last = 0;
    int bad_full = 0;
    // Start popping the queue and inserting canonical forms
    while( !nqueue.empty() )
    {
        qnode curr = nqueue.top();
        nqueue.pop();

        //If it's the second to last insertion we can do the trivial insertion as well.
        bool last_insert = false;
        if(curr.get_next_freq() == (freqs.size() - 2))
        {
            last_insert = true;
            last_counter++;
        }

        //Get the vector of canonical forms that have the same number of frequencies needed
        //by the current qnode
        int next_freq = freqs[curr.get_next_freq()] - '0' - 1;
        vector<cform> curr_forms = forms.at(next_freq);

        //If we're limiting values then we want to skip frequencies that we know won't work.
        int skip = ((lim > 0) && (next_freq == 0)) ? cstart[lim] : 0;

        
        for(int i=skip; i<curr_forms.size(); i++)
        {
            //insert sets valid to false if the cform cannot be inserted
            bool valid = true;
            qnode temp = curr.insert(curr_forms[i], valid, last_insert);
            
            if(valid)
            {
                //Check if we have found a counter-example
                if(temp.get_trans() <= 0)
                {
                    if(verbose) cout << "! #" << counter_count++ << " - Counter-Example Found:" << endl; 
                    if(dreadly) temp.print_dread(initial, counter_count);
                    else temp.print_clean();
                    //return EXIT_SUCCESS;
                }
                //Check if the matrix is full or not
                else if(temp.get_next_freq() < freqs.size())
                {
                    valid_count++;
                    //Matrix is not full!
                    ihash = nhash.insert(temp);
                    if(ihash.second)
                    {
                        insert_count++;
                        nqueue.push( temp );
                    }
                }
                //Else it is full but not a counter example
                else
                {
                    bad_full++;
                }
            }

            if(verbose && insert_count % 100 == 0 && insert_count != last)
            {
                last = insert_count;
                if(verbose) cout << "!Valid: " << valid_count << "\tInsert: " << insert_count;
                if(verbose) cout << "\tLast Insertions: " << last_counter << " (" << bad_full << ")" << endl;
            }
        }
    }

    if(verbose) cout << "!Queue Cleared." << endl;
    if(verbose) cout << "!Valid Insertions: " << valid_count << "\tActual Insertions: " << insert_count << endl;

    return 0;
}
