/*
 *  The first attempt at a program to find transversal counterexamples in rectangles
 *
 *  Procedure:
 *
 *  1)  Generate the canonical forms using util/gen_canon.cpp (instructions included in file.)
 *  2)  Create an input file as described below.
 *  3)  Compile the file (eg: clang++ clutch.cpp -O3 -oclutch)
 *  4)  Run (eg: ./clutch < input.txt)
 *
 *
 *  Input File Format:
 *
 *      N.B:    This format was created from combining previous utilities and experiments and
 *              will most likely be replaced with something better eventually.
 *
 *              Frequencies cannot exceed a single digit. (Shouldn't be a problem for the sizes
 *              we are expecting.)
 *
 *              Only attemps one configuration of frequencies, allowing for multiple instances
 *              to be run using different frequency setups as the program is not multithreaded
 *              whatsoever.
 *
 *      n m fmax                        (Number of rows, columns, and maximum frequency)
 *      f1f2f3f4...fn                   (list of frequencies starting with fmax)
 *      canon_list_fmax.file            (Path to canonical form files generated by util/gen_canon)
 *      canon_list_fmax-1.file
 *      ...
 *      canon_list_1.file
 *
 *  TODO:
 *          - Don't insert cforms we know won't work
 *          - Check if the transversal is the same and don't insert it if it is
 */

#include <iostream>
#include <fstream>
#include <vector>
#include <queue>
#include "qnode.h"
#include "cform.h"

using namespace std;

int main(int argc, char **argv)
{
    bool verbose = true;
    int m, n, f;
    string fline, freqs;
    vector< vector<cform> > forms;
    priority_queue< qnode, vector<qnode>, less<vector<qnode>::value_type> > nqueue;
    
    //---- Reading data from input files
    
    cin >> m >> n >> f;
    forms.resize(f);
    if(verbose) cout << "m n f: " << m << " " << n << " " << f << endl;

    getline(cin, freqs);
    getline(cin, freqs);
    if(verbose) cout << "Freqs: " << freqs << endl;
    
    int curr = f;
    //-------- Reading canonical forms
    while(getline(cin, fline) && curr >= 0)
    {
        if(verbose) cout << "Opening File: " << fline << endl;
        ifstream fhandle;
        string sline;
        vector<cform> vec;

        fhandle.open(fline.c_str(), ifstream::in);
        if(fhandle.is_open())
        {
            int lc=1;
            int count=0;
            while(getline(fhandle, sline))
            {
                if(lc%(m*n+4) == 0)
                {
                    //Output matrix
                    //if(verbose) cout << sline << endl;
                    if(curr == f)
                        nqueue.push( qnode(sline, count++, m, n) );
                    vec.push_back( cform(sline, m, n, false) );
                    vec.push_back( cform(sline, m, n, true) );
                }
                lc++;
            }
            sort(vec.begin(), vec.end());
            cout << "Insert Forms " << curr << " " << vec.size() << endl;
            forms[--curr] = vec;
        }
        else
        {
            cout << "Could not open file: " << fline << endl;
            //return 1;
        }
    }
    
    //Print canonical forms
    if(verbose) 
    {
        cout << "Canon Queue: (" << forms.size() << ") " << endl;
        for(int i=forms.size()-1; i>=0; i--)
        {
            cout << "f == " << (i+1) << " (" << forms[i].size() << ") " << endl;
            for(int j=0; j<forms[i].size(); j++)
               forms.at(i).at(j).print_clean(4,4);
        }
    }
    
    //Initial vectors that describe the way the rows and columns are permuted
    // init_rows = [1,m]
    // init_cols = [1,n]
    vector<int> init_rows;
    vector<int> init_cols;
    for(int i=1; i<=m; i++)
    {
        init_rows.push_back(i);
    }
    for(int i=1; i<=n; i++)
    {
        init_cols.push_back(i);
    }

    if(verbose) cout << "Queue Size: " << nqueue.size() << endl;
    // Start popping the queue and inserting canonical forms
    while( !nqueue.empty() )
    {
        qnode curr = nqueue.top();
        nqueue.pop();

        //Get the vector of canonical forms that have the same number of frequencies needed
        //by the current qnode
        int next_freq = freqs[curr.get_next_freq()] - '0' - 1;
        vector<cform> curr_forms = forms.at(next_freq);
        
        for(int i=0; i<curr_forms.size(); i++)
        {
            //For every canonical form make a copy of the row and column permutation vectors
            //and attempt to insert every permutation of it
            vector<int> curr_rows = init_rows;
            do
            {
                vector<int> curr_cols = init_cols;
                do
                {
                    //insert sets valid to false if the cform cannot be inserted
                    bool valid = true;
                    qnode temp = curr.insert(curr_forms[i], curr_rows, curr_cols, valid);
                    
                    if(valid)
                    {
                        //Check if we have found a counter-example
                        if(temp.get_trans() <= 0)
                        {
                            cout << "Counter-Example Found: (" << temp.get_trans() << ") " << endl;
                            temp.print_clean();
                            //return EXIT_SUCCESS;
                        }
                        //Check if the matrix is full or not
                        else if(temp.get_next_freq() < freqs.size())
                        {
                            //Matrix is not full!
                            nqueue.push( temp );
                        }
                    }
                }
                while(next_permutation(curr_cols.begin(), curr_cols.end()));
            }
            while(next_permutation(curr_rows.begin(), curr_rows.end()));
        }
    }

    cout << "Queue Cleared." << endl;
    return 0;
}
